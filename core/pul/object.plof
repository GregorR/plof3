/*
 * Basic members of Object and Function
 *
 *  Copyright (c) 2008  Gregor Richards
 *  
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the "Software"), to
 *  deal in the Software without restriction, including without limitation the
 *  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 *  sell copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *  
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *  
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 *  IN THE SOFTWARE.
 */

// the Function type will be filled in later, but for the moment we can just stub it
var Function = Object : [];

// trivial plof function calls
plofbnf {
    plof_group = plof_group plof_group_next => plof {
        psl { $1 1 integer array $0 pul_eval call }
    }

    plof_group = plof_group "\(" plof_args "\)" => plof {
        psl { $2 pul_eval $0 pul_eval call }
    }


    plof_args = plof_args "," plof_args_next => plof {
        psl { $0 pul_eval $2 pul_eval aconcat }
    }

    plof_args = plof_args_next "," plof_args_next => plof {
        psl { $0 pul_eval $2 pul_eval aconcat }
    }

    plof_args => plof_arg;

    plof_arg = plof_semicolon_next => plof {
        psl { $0 1 integer array }
    }
};

// FIXME: Should use proper combination
var opFunction = Function:psl { {
    // get the procedure
    this "proc" push2 0 integer index pul_eval memberset

    // combine it with Function
    plof { Function:proc } pul_eval
} };


// opMember is a function ...
Object.opMember = Function:psl { {
    // args: [name, next context]
    this "name" push2 0 integer index pul_eval memberset
    this "next" push2 1 integer index pul_eval memberset

    // first check if we have this
    null this "this" resolve member this "name" member member null
    {
        // it's not here, try the type
        this "__pul_type" resolve member 1 integer 2 integer array
        {
            // args: [type, index]

            // make sure we're not beyond the end of the array
            push0 0 integer index length push1 1 integer index
            {
                // not found
                new
                push0 "__pul_opmember_search" new memberset
                push0 "__pul_opmember_found" null memberset
                throw
            }
            {
                // OK, check if that type has this
                push0 0 integer index push1 1 integer index index
                
                push0 this "name" resolve member member null
                {}
                {
                    // found it, get it
                    push0 this "name" resolve member member 

                    // then duplicate it
                    this "opDuplicate" resolve member call

                    // reparent it
                    push0 this "this" resolve member parentset

                    // and assign it into us
                    this "this" resolve member this "name" resolve member push2 memberset

                    // now make it a reference
                    this "this" resolve member this "name" resolve member pul_varwrap

                    // then throw it
                    new
                    push0 "__pul_opmember_search" new memberset
                    push0 "__pul_opmember_found" push3 memberset
                    throw
                } cmp

                pop
            } lte

            // add and loop
            push0
                1 integer
                    push1 1 integer index
                    1 integer
                    add
            indexset
            loop
        }
        {
            // is this our response?
            push0 "__pul_opmember_search" null
            {
                // no, throw it again
                throw
            }
            {
                // Yes. Is it null?
                "__pul_opmember_found" member push0 null
                {
                    // Yes. Check with the next guy.
                    this "name" resolve member "opMember"
                    this "next" resolve member
                    push2 push2 2 integer array resolve
                    4 integer array

                    // now check whether we used opMember or the name
                    push0 1 integer index
                    push1 3 integer index
                    {
                        // used opMember, call it
                        push0 0 integer index
                        push1 2 integer index parent 2 integer array
                        push1 2 integer index "opMember" member pul_eval call
                    }
                    {
                        // no opMember
                        push0 2 integer index
                        push1 0 integer index
                        member
                    } cmp
                }
                {
                    // Found it, just pass it along.
                } cmp
            } cmp
        } catch
    }
    {
        // we have it, simple enough
        this "this" resolve member
        this "name" resolve member
        pul_varwrap
    } cmp
} };
psl { this "Object" resolve member push0 "opMember" member push1 parentset pop };


// more advanced function syntax
plofbnf {
    plof_group = "\(" plof_params "\)" "\{" plof_funcbody "\}" => {
        // get the params for future reference
        null push1 1 integer index call

        // make this a function context
        {
            this "__pul_fc" this memberset
            this "__pul_proc" this "+procedure" member memberset
            this "__pul_args" push2 memberset

            // curry if necessary
            push0 length } push1 0 integer index swrap concat {
            {
                // currying is necessary
                {
                    this "__pul_args" resolve member
                    push1 aconcat
                    this "__pul_proc" resolve member call
                } 1 integer array this "opFunction" resolve member call
            }
        } concat

        // everything from here on is in the not-currying case

        // set up the args
        {pul_fcontext 0 integer}
        push2 1 integer index concat
        {
            pop pop pop
        } concat
        
        // then run the function itself
        push3 4 integer index concat

        // and make sure it's evaluated
        {pul_eval} concat

        // wrap it up for deep returns
        cwrap
        {
            {
                // is this our deep return?
                push0 "__pul_ret_fc" member pul_fcontext
                {
                    // yes, return it
                    "__pul_ret_val" member
                }
                {
                    // no, throw it along
                    throw
                } cmp
            } catch
        } concat

        // wrap it up in the lt case
        cwrap concat { lt } concat

        // wrap it up with opFunction
        cwrap {1 integer array this "opFunction" resolve member call} concat

        // then wrap the whole thing up
        cwrap {pul_funcwrap} concat
    }

    
    plof_params = white => {
        {0 integer {} 2 integer array}
    }


    plof_params = plof_params "," plof_params_next => {
        null push1 0 integer index call
            push0 0 integer index 1 integer add swrap
            push1 1 integer index push3 2 integer index concat cwrap concat
            {2 integer array} concat
    }

    plof_params = plof_params_next => {
        {1 integer}
        push1 0 integer index cwrap concat
        {2 integer array} concat
    }

    plof_params => plof_param;


    // type annotations to come later
    plof_param = plof_identifier => {
        // this.name ...
        {push1}
        push1 0 integer index concat

        // inner stack: args fcontext index fcontext name

        // = the val
        {
            push4 push3 index memberset
        
            // and increment
            1 integer add
        } concat
    }


    plof_funcbody = white => { {} }
    plof_funcbody = plof_funcbody_next => plof { $0 }
    plof_funcbody => plof_funcbody_prime;

    plof_funcbody_prime = plof_semicolon => plof { $0 }


    // deep returns
    plof_group = "return" plof_group_next => plof {
        psl {
            new
                push0 "__pul_ret_fc" pul_fcontext memberset
                push0 "__pul_ret_val" $1 memberset
            throw
        }
    }

};

plofbnf {
    plof_group = "\{" plof_funcbody "\}" => plof {
        () { $1 }
    }
};
