/*
 * The Plof User Language basic definitions. This file gets you from the grammar defined in base.psl
 * to a functional PUL grammar, and creates mostly-empty Object and Function objects. object.pul
 * should be loaded next to flesh out the important objects.
 *
 *  Copyright (c) 2007, 2008, 2009  Gregor Richards
 *  
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the "Software"), to
 *  deal in the Software without restriction, including without limitation the
 *  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 *  sell copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *  
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *  
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 *  IN THE SOFTWARE.
 */

psl {
    /* PUL objects can potentially be unevaluated. This function evaluates
     * unevaluated objects, or just returns the object if it has been evaluated */
    global "__pul_eval" {
        // is __pul_v set?
        push0 "__pul_v" member null
        {
            // no __pul_v, how 'bout __pul_e?
            push0 "__pul_e" member null
            {
                // neither, it's just a value
            }
            {
                // __pul_e is set, call it
                null push1 "__pul_e" member call
                global "__pul_eval" member call
            } cmp
        }
        {
            // __pul_v is set, use it
            "__pul_v" member
            global "__pul_eval" member call
        } cmp
    } memberset

    global "__pul_forceEval" {
        // is __pul_e set?
        push0 push0 "__pul_e" member null
        {
            // neither, it's just a value
        }
        {
            // call __pul_e
            null push1 "__pul_e" member call
            global "__pul_eval" member call
        } cmp
    } memberset

    // PUL returns are by-ref, so you can set through them. __pul_set does so
    global "__pul_set" {
        // arg: [byref object, new value]

        // make sure __pul_s is set
        push0 0 integer index "__pul_s" member null
        {
            // not set: This should be handled better (FIXME)
        }
        {
            // OK, set it
            push0 1 integer index
            push1 0 integer index "__pul_s" member call
        } cmp
    } memberset

    // create an unevaluated value from a procedure
    global "__pul_funcwrap" {
        // arg: procedure

        // put the procedure in a variable
        this "proc" push2 memberset

        // then make an object
        new

        // first, __pul_e
        push0 "__pul_e" {
            null this "proc" resolve member call
            global "__pul_eval" member call
        } memberset

        // then __pul_s
        push0 "__pul_s" {
            null this "proc" resolve member call
            push1 2 integer array
            global "__pul_set" member call
        } memberset
    } memberset


    // create an unevaluated value from a variable
    global "__pul_varwrap" {
        // arg: [context, name]

        // put the argument in a var
        this "arg" push2 memberset

        // then make an object
        new

        // first, __pul_e
        push0 "__pul_e" {
            this "arg" resolve member
            push0 0 integer index

            // check if we have it directly
            push1 1 integer index member null
            {
                // OK, maybe opMember?
                push0 0 integer index
                "opMember" member null
                {
                    // neither: Fail
                    null
                }
                {
                    // use opMember
                    push0 1 integer index null 2 integer array
                    push1 0 integer index "opMember" member
                    global "__pul_eval" member call
                    call
                } cmp
            }
            {
                // have it directly, easy
                push0 0 integer index
                push1 1 integer index
                member
            } cmp
        } memberset

        // then, __pul_s
        push0 "__pul_s" {
            this "arg" resolve member
            push0 0 integer index
            push1 1 integer index
            push3
            memberset
        } memberset
    } memberset

    // create an unevaluated value for the parent of an object
    global "__pul_parentwrap" {
        // arg: object

        // put the argument in a var
        this "obj" push2 memberset

        // then make an object
        new

        // first, __pul_e
        push0 "__pul_e" {
            this "obj" resolve member
            parent
        } memberset

        // then, __pul_s
        push0 "__pul_s" {
            this "obj" resolve member
            push1
            parentset
        } memberset
    } memberset


    // PUL functions are marked with the variable __pul_fc. This finds it
    global "__pul_fcontext" {
        // arg: context
        "__pul_fc" resolve pop
    } memberset
};

// the top context is a PUL fcontext
psl {
    this "__pul_fc" this memberset
};


// Integers
psl {
    // basic opInteger, filled in later
    pul_fcontext "opInteger" {
        new push0 "__pul_val" push3 0 integer index memberset
    } memberset
};


// The most important object in the game, Object
psl {
    new push0 pul_fcontext parentset

    // top.Object = ...
    pul_fcontext "Object" push2 memberset

    // Object.this = Object
    push0 "this" push2 memberset

    // Object.__pul_type = [Object]
    push0 "__pul_type"
        push2 1 integer array 
        push0 push4 parentset
    memberset

    // opDuplicate to duplicate objects
    pul_fcontext "opDuplicate"
    {
        push0 0 integer index

        // make the new object
        new combine

        // object.this = object
        push0 "this" push2 memberset

        // objects are function contexts
        push0 "__pul_fc" push2 memberset

        // their type is based on the parent type (if set)
        push0 "__pul_type" member null
        {
            // no parent type
            push0 "__pul_type"
                push2 1 integer array
            memberset
        }
        {
            // use the parent type
            push0 "__pul_type"
                push2 1 integer array
                push3 "__pul_type" member pul_eval
                aconcat
                push0 push4 parentset
            memberset
        } cmp

        // copy opMember (if set)
        push0 "opMember" member null
        {}
        {
            push0 "opMember"
                push2 "opMember" member pul_eval
                new combine push0 push4 parentset
            memberset
        } cmp

        // and reparent everything
        push0 push2 0 integer index 2 integer array
        this "opReparent" resolve member call pop
    } memberset

    // opReparent reparents members of $0 from $1
    pul_fcontext "opReparent"
    {
        this "object"  push2 0 integer index memberset
        this "old"     push2 1 integer index memberset
        this "members" push2 0 integer index members memberset
        this "index"   0 integer memberset

        null
        {
            // we've finished if the index is >= the length
            this "index" resolve member
            this "members" resolve member length
            { global } { null } lt
        }
        {
            // no, check this one
            this "object" resolve member
                this "members" resolve member
                    this "index" resolve member
                        index
                    member

                // if the parent is the old one, we'll reparent
                parent this "old" resolve member
                {
                    this "object" resolve member
                        this "members" resolve member
                            this "index" resolve member
                                index

                            // now we have the object and the name, so reparent it
                            push1 push1 member
                                1 integer array
                                this "opDuplicate" resolve member call pul_eval
                                push0 push3 parentset
                                memberset
                }
                {} cmp

                // and increment the index
                this "index" resolve
                        this "index" resolve member 1 integer add
                            memberset
        } while pop
    } memberset

    // opCombine is defined below as it depends on duplication
};


psl {
    // opCombine reconciles combined objects
    pul_fcontext "opCombine"
    {
        // arg: [old1, old2, new]
        this "old1" push2 0 integer index memberset
        this "old2" push2 1 integer index memberset
        push0 2 integer index this "new" push2 memberset

        // object.this = object
        push0 "this" push2 memberset

        // objects are function contexts
        push0 "__pul_fc" push2 memberset
        pop

        // their type is based on the parent types (if set)
        this "old1" member "__pul_type" member pul_eval null
        {
            // none on the left, how 'bout the right
            this "old2" resolve member "__pul_type" member pul_eval null
            {
                // none on either side, just use itself
                this "new" resolve member "__pul_type"
                    push1 1 integer array
                memberset
            }
            {
                // right but not left
                this "new" resolve member "__pul_type"
                    push1 1 integer array
                    this "old2" resolve member "__pul_type" member pul_eval
                    aconcat
                memberset
            } cmp
        }
        {
            // left is set, how 'bout the right
            this "old2" resolve member "__pul_type" member pul_eval null
            {
                // left but not right
                this "new" resolve member "__pul_type"
                    push1 1 integer array
                    this "old1" resolve member "__pul_type" member pul_eval
                    aconcat
                memberset
            }
            {
                // both set
                this "new" resolve member "__pul_type"
                    push1 1 integer array
                    this "old2" resolve member "__pul_type" member pul_eval
                    aconcat
                    this "old1" resolve member "__pul_type" member pul_eval
                    aconcat
                memberset
            } cmp
        } cmp

        // reparent all members
        this "new" member
        this "old1" member
        2 integer array
        this "opReparent" resolve member call pop
        this "new" member
        this "old2" member
        2 integer array
        this "opReparent" resolve member call pop

        2 integer index
    } memberset
};
