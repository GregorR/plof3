/*
 * Dynamic type annotations for Plof
 *
 *  Copyright (c) 2007, 2008  Gregor Richards
 *  
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the "Software"), to
 *  deal in the Software without restriction, including without limitation the
 *  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 *  sell copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *  
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *  
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 *  IN THE SOFTWARE.
 */

// typechecking in Object
Object := [
    opIs = (type) {
        psl {
            this "mytype"
            plof{this} pul_eval "__pul_type" member
            memberset
            this "index" 0 memberset

            // go through each element
            null
            {
                this "index" resolve member
                this "mytype" resolve member length
                { global } { null } lt
            }
            {
                // check this one
                this "mytype" resolve member
                    this "index" resolve member
                        index
                    plof{type} pul_eval
                {
                    // they're equal, this matches
                    plof{return True} pul_eval
                }
                {
                    // no match
                } cmp

                // increment the index
                this "index" resolve
                        this "index" resolve member
                            1 add
                            memberset
            } while pop

            // didn't find it
            plof{return False} pul_eval
        }
    }

    // perform a cast iff possible
    opCast = (type) {
        if (!((var ret = this.opCastTo(type)) is Null)) (
            return ret
        ) else if (!((var ret = type.opCastFrom(this)) is Null)) (
            return ret
        ) else (
            throw (new OpAsException(this, type))
        )
    }

    opAs = (type) {
        if (this is type) (
            // simple case
            return this
        )
        return (opCast(type))
    }

    opCastTo = (type) {
        Null
    }

    opCastFrom = (obj) {
        Null
    }
]

// set up intrinsics
psl {
    plof{Object.opIs} pul_eval 3 intrinsic
    plof{Object.opAs} pul_eval 4 intrinsic
}

// OpAsException is thrown when OpAs fails
var OpAsException = Object : [
    from = Null
    tto = Null

    this (from, tto) {
        this.from = from
        this.tto = tto
    }
]
