\begin{longtable}{ | l | l | l | X | }
\hline
\textbf{Hex} & \textbf{Name} & \textbf{Stack behavior} & \textbf{Function} \\
\hline\hline
00-07 & push0-push7 & 0 $\rightarrow$ 1 & Push\textit{n} pushes the \textit{n}th element of the stack onto the top of the stack. e.g., for the stack:

original stack: a, b, c

after push0: a, b, c, c

after push2: a, b, c, a \\
\hline
08 & pop & 1 $\rightarrow$ 0 & Pop an object from the stack. \\
\hline
09 & this & 0 $\rightarrow$ 1 & Push the context object. \\
\hline
0A & null & 0 $\rightarrow$ 1 & Push the null object. \\
\hline
0B & global & 0 $\rightarrow$ 1 & Push the global object. \\
\hline
0C & new & 0 $\rightarrow$ 1 & Pushes a new object. The new object has no members set and its parent is set to the current context. \\
\hline
0E & member & 2 $\rightarrow$ 1 & Get a member from an object. Pops the object then the name of the member from the stack, and pushes the member object. \\
\hline
0F & memberset & 3 $\rightarrow$ 0 & Set a member in an object. Pops the object, the name of the member and the new member object from the stack. \\
\hline
10 & parent & 1 $\rightarrow$ 1 & Get the parent of an object. Pops the object, pushes its parent. \\
\hline
11 & parentset & 

2 $\rightarrow$ 0 & 

Set the parent of an object. Pops two objects, sets the parent of the first to the second. \\
\hline
12 & call & 2 $\rightarrow$ 1 & Call a procedure. Pops an argument object and the object containing the procedure. The procedure is called with a new stack containing only the argument object that was popped. A new context object is created for the procedure, the parent of which is set to the parent of the procedure object. The context contains at least one member, “+procedure”, the value of which is the procedure object. When the procedure finishes, the top element from its stack (or \textit{null} if its stack is empty) is pushed onto the calling stack, and the procedure's stack is discarded. \\
\hline
13 & return & (special) & Return from the current procedure. \\
\hline
14 & throw & (special) & Throw an object. Pops the object to be thrown. Everything on the stack which was pushed by contexts which are unwound is popped. \\
\hline
15 & catch & 3 $\rightarrow$ 1 & Catch an object. Pops two procedures. The first procedure is called. If an exception is thrown, all of the objects pushed onto the stack by the first procedure are popped, the thrown object is pushed, and the second procedure is called. \\
\hline
16 & cmp & 5 $\rightarrow$ 1 & Compare two objects and branch based on their equality. Pops two objects and two procedures. If the two objects are equal, the first procedure is called, otherwise the second procedure is called. \\
\hline
17 & concat & 2 $\rightarrow$ 1 & Concatenate the raw data in two objects. Pops the two objects, and pushes a new object. The raw data of the two objects are concatenated into the new object. The new object does not have any members, and its parent is set to the current context object. \\
\hline
18 & wrap & 2 $\rightarrow$ 1 & Wrap raw data in an operation to push it, outputting a raw data object containing PSL code. Pops two raw data objects, the first with the data to be wrapped and the second with the operation it should be wrapped in, and pushes a raw data object. \\
\hline
19 & resolve & 2 $\rightarrow$ 2 & Find an object with a given member. Pops an object and a name or array of names. Given only a single name (as raw data), finds the nearest parent of the object with the given name as a member with a value other than \textit{null}. Given multiple names (as an array of raw data objects), finds the nearest parent of the object with \textit{any} of the given names. Pushes the found object and found name. If no object/name combo is found, pushes \textit{null} twice. \\
\hline
%1A & while & 3 $\rightarrow$ 1 & Run a section of code repeatedly. Pops an argument object and two procedures. The first procedure represents the condition, the second procedure represents the code to be repeated. The loop is run like so:<ul><li>
%
%<span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm;">•.</span>The condition is run, with \textit{null} as an argument.<span class="odfLiEnd"/> </li><li>
%
%<span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm;">•.</span>If the condition returned \textit{null}, the code is not run and the argument object is returned to the stack.<span class="odfLiEnd"/> </li><li>
%
%<span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm;">•.</span>If the condition returned any other value, the code is run with the argument object as an argument, and its return replaces the argument object. The loop then repeats from running the condition, as above.<span class="odfLiEnd"/> </li></ul> \\
%\hline
1B & calli & 1 $\rightarrow$ 0 & Run the immediates in a procedure. Pops an object containing the procedure. The code contained in any \textit{immediate} instructions will be run (with \textit{null} as the argument). \\
\hline
1C & replace & 2 $\rightarrow$ 1 & Replace markers with raw data in raw data. Pops a raw data object and an array of raw data objects. In the first argument, markers associated with the index of each element of the second argument are replaced with the data in the same index. That is, a marker with the (one-byte) value 0 will be replaced with the first element in the array. This is done with PSL code in mind: That is, if a marker is replaced within a \textit{code} operation, its length will be updated correctly. Markers are not replaced within \textit{raw} operations. The parent of the pushed object is the parent of the first raw data operand. \\
\hline
20 & array & >0 $\rightarrow$ 1 & Creates an array from elements on the stack. The top element on the stack should be an integer (see the \textit{integer} operation), the length of the array. The length is popped, and the appropriate number of elements are popped below it, and added to the array. They will appear in the array in the order that they appear in on the stack, which is of course the order in which they were pushed. The parent of the array is set to the current context object. \\
\hline
21 & aconcat & 2 $\rightarrow$ 1 & Identical to \textit{concat}, but for arrays. \\
\hline
22 & length & 1 $\rightarrow$ 1 & Get the length of an array. Pops the array object and pushes its length. \\
\hline
23 & lengthset & 2 $\rightarrow$ 0 & Set the length of an array. Pops the array object and an integer for the new length, and sets the length of the array, padding with \textit{null}s as necessary. \\
\hline
24 & index & 2 $\rightarrow$ 1 & Get an element out of an array. Pops the array object and the index as an integer, and pushes the element. \\
\hline
25 & indexset & 3 $\rightarrow$ 0 & Set an element in an array. Pops the array object, the index as an integer and the object to be assigned, and assigns it as appropriate. If the array is not long enough, it is expanded. \\
\hline
26 & members & 1 $\rightarrow$ 1 & Pushes an array (see \textit{array}) containing the names for all of the members of an object. Pops the object, pushes the array. The parent of the array is the current context, as is the parent of each raw data object in the array. \\
\hline
60 & rawlength & 1 $\rightarrow$ 1 & Get the length of raw data. Pops a raw data object, pushes an integer of its length. \\
\hline
61 & slice & 3 $\rightarrow$ 1 & Slice raw data. Pops a raw data object and two integers, the start and the end. Pushes a raw data object, the data of which is the content of the original raw data, starting at the start byte requested (0-indexed), including the bytes up to but not including the end byte. \\
\hline
62 & rawcmp & 2 $\rightarrow$ 1 & Compare two raw data objects. Pops two raw data objects and pushes an integer. This operation corresponds to the C function memcmp, so the integer will be 0 if the two data are equal, -1 if the first is “less than” the second, and 1 if the first is “greater than” the second, as defined by memcmp. \\
\hline
70 & integer & 1 $\rightarrow$ 1 & Converts raw data into the most efficient integer format of the host. The raw data can be an 8-, 16-, 32- or 64-bit, big-endian integer. Pops the raw general integer and pushes a host-specific integer. The properties and restrictions of integers in PSL are defined in appendix A. The parent of the new integer, if defined, is the same as the parent of the original data. The size of the integer is left intentionally undefined. \\
\hline
71 & intwidth & 0 $\rightarrow$ 1 & Push an integer containing the width of host integers, in bits. \\
\hline
72 & mul & 2 $\rightarrow$ 1 & Integer multiply. \\
\hline
73 & div & 2 $\rightarrow$ 1 & Integer divide. If the second number is 0, pushes null. \\
\hline
74 & mod & 2 $\rightarrow$ 1 & Integer modulo. If the second number is 0, pushes null. \\
\hline
76 & add & 2 $\rightarrow$ 1 & Integer add. \\
\hline
77 & sub & 2 $\rightarrow$ 1 & Integer subtract. \\
\hline
78 & lt & 5 $\rightarrow$ 1 & Pops two integers and two procedures. If the first integer is less than the second integer, the first procedure is called, otherwise the second procedure is called. \\
\hline
79 & lte & 5 $\rightarrow$ 1 & Less than or equal to. \\
\hline
7A & eq & 5 $\rightarrow$ 1 & Equal. \\
\hline
7B & ne & 5 $\rightarrow$ 1 & Not equal. \\
\hline
7C & gt & 5 $\rightarrow$ 1 & Greater than. \\
\hline
7D & gte & 5 $\rightarrow$ 1 & Greater than or equal to. \\
\hline
7E & sl & 2 $\rightarrow$ 1 & Shift left. \\
\hline
7F & sr & 2 $\rightarrow$ 1 & Shift right (arithmetic) \\
\hline
80 & or & 2 $\rightarrow$ 1 & Bitwise or. \\
\hline
81 & nor & 2 $\rightarrow$ 1 & Bitwise nor. \\
\hline
82 & xor & 2 $\rightarrow$ 1 & Bitwise xor. \\
\hline
83 & nxor & 2 $\rightarrow$ 1 & Bitwise nxor. \\
\hline
84 & and & 2 $\rightarrow$ 1 & Bitwise and. \\
\hline
85 & nand & 2 $\rightarrow$ 1 & Bitwise nand. \\
\hline
8E & byte & 1 $\rightarrow$ 1 & Convert an integer modulo 256 to a single raw byte. Pops the integer as raw data and pushes the byte as raw data. \\
\hline
90 & float & 1 $\rightarrow$ 1 & Converts an integer into the most efficient floating point form of the host. Pops an integer, pushes a float. Like integers, floating point numbers are only defined over their own range (91-AF), so they can be implemented by whatever means is most efficient. \\
\hline
91 & fint & 1 $\rightarrow$ 1 & Floor a floating point number into an integer. \\
\hline
92 & fmul & 2 $\rightarrow$ 1 & Floating-point multiplication. \\
\hline
93 & fdiv & 2 $\rightarrow$ 1 & Floating-point division. If the second number is 0, pushes null. \\
\hline
94 & fmod & 2 $\rightarrow$ 1 & Floating-point modulo. If the second number is 0, pushes null. \\
\hline
96 & fadd & 2 $\rightarrow$ 1 & Floating-point addition. \\
\hline
97 & fsub & 2 $\rightarrow$ 1 & Floating-point subtraction. \\
\hline
98 & flt & 5 $\rightarrow$ 1 & Floating-point less than (see \textit{lt}). \\
\hline
99 & flte & 5 $\rightarrow$ 1 & Floating-point less than or equal to. \\
\hline
9A & feq & 5 $\rightarrow$ 1 & Floating-point equal. \\
\hline
9B & fne & 5 $\rightarrow$ 1 & Floating-point not equal. \\
\hline
9C & fgt & 5 $\rightarrow$ 1 & Floating-point greater than. \\
\hline
9D & fgte & 5 $\rightarrow$ 1 & Floating-point greater than or equal to. \\
\hline
C0 & version & 0 $\rightarrow$ 1 & Pushes an array of strings (as raw data), each of which is a specifier for the host environment. Exactly what is contained is open-ended, but in general it will include the architecture, kernel, standard library and native interface. Some examples are provided in appendix C. \\
\hline
  &   &   & The operations C1-CF are reserved for native interfacing. They are not defined in this specification, since they can potentially be different for different implementations. Instead, they are defined by auxiliary specifications. Appendix D describes one design, CNFI. \\
\hline
  &   &   & The operations D0-DF are useful for debugging. If debugging is enabled, they will be generated automatically by the runtime parser and used by the PSL interpreter, and so should not generally need to be used in writing PSL code. \\
\hline
D0 & dsrcfile & 1 $\rightarrow$ 0 & Set the source file of the current PSL code to the provided raw data. Pops a raw data object. \\
\hline
D1 & dsrcline & 1 $\rightarrow$ 0 & Set the source line of the current PSL code to the provided value. Pops an integer. \\
\hline
D2 & dsrccol & 1 $\rightarrow$ 0 & Set the source column of the current PSL code to the provided value. Pops an integer. \\
\hline
ED & trap & 2 $\rightarrow$ 1 & See appendix B. \\
\hline
EE & include & 1 $\rightarrow$ 1 & Pops the name of a file, and pushes the content of that file. If the file was not found or for any reason cannot be read, \textit{null} is pushed. The directories in which the file will be searched for are defined by the implementation. \\
\hline
  &   &   & The operations EF-FD affect the runtime parser. The details of the runtime parser are discussed in a later section. \\
\hline
EF & parse & 3 $\rightarrow$ 1 & Parse Plof code or a PSL file with the runtime parser. Pops the raw data of the Plof code or PSL file content, the name of the top symbol in the runtime parser and the name of the file that the code represents (for generating debugging data), and pushes raw data of the resultant PSL code. If the data is a PSL file matching the PSL specification in this document, the contained PSL code will be extracted and returned as a procedure directly, otherwise it is assumed to be Plof code and parsed with the runtime parser. \\
\hline
F0 & gadd & 3 $\rightarrow$ 0 & Add a production to the grammar. Pops the production name, the production, and the associated PSL code. \\
\hline
F1 & grem & 1 $\rightarrow$ 0 & Remove a production from the grammar. Pops the production name and removes it. \\
\hline
FB & gcommit & 0 $\rightarrow$ 0 & Commit grammar changes. \\
\hline
FC & marker & 0 $\rightarrow$ 0 & Serves no purpose but to be replaced with \textit{the replace }operation above. Contains a marker symbol provided like raw data. \\
\hline
FD & immediate & 0 $\rightarrow$ 0 & The provided code, which is provided like raw data (see below), is run in the compilation phase, not the runtime phase. When the PSL code is provided in PSL form, this code is run before anything else. When the PSL code is generated by the runtime parser (which is discussed below), this code is run as soon as it is generated. The operations which affect the runtime parser (F0-FD) cannot be run outside of an \textit{immediate} operation. \\
\hline
FE & code & 0 $\rightarrow$ 1 & Push raw data which is code. Works identically to \textit{raw} (below), but is intended for PSL code. This allows the \textit{replace} operation to work, and also can help optimizations. \\
\hline
FF & raw & 0 $\rightarrow$ 1 & Push raw data. The operation itself is immediately followed by a bignum number (the format of which is described below), which represents the number of bytes of raw data. The data itself follows immediately after the length. The raw data is pushed in an otherwise-empty object, the parent of which is the current context object. \\
\hline
\end{longtable}
