\chapter{Plof User Language}

The Plof User Language (called simply Plof, or PUL to differentiate it from the rest of the Plof environment) is the language that programmers most commonly see, and is implemented as a runtime grammar in the Plof Runtime Parser, compiling to PSL code.



\section{PUL ABI}

Because PUL has some advanced features unsupported in PSL, many fundamental PUL operations compile to several PSL operations or procedures, and some constructs are represented in abstract ways.



\subsection{Indirection Objects}

PUL is a lazy language. As such, values in PUL can be represented by special objects providing indirect access to a procedure to evaluate the value. These are called indirection objects. Indirection objects have three significant members: \_\_pul\_e, \_\_pul\_s and \_\_pul\_v.

\_\_pul\_e is the procedure to evaluate the value. It does not expect anything on the stack, and it pushes the value. It may return the ultimate value, or it may return another indirection object. For that reason, it shouldn't be used directly, but through the \_\_pul\_eval procedure (which will be discussed later).

\_\_pul\_s, which is only set when applicable, is the procedure to set the value. It pops the new value, and pushes nothing. The value being assigned must be fully evaluated; that is, it must not be an indirection object.

\_\_pul\_v is the cached value if it has already been evaluated. If it has not been evaluated, \_\_pul\_v is unset.



\subsection{Helper Procedures}

There are several global procedures in the Plof environment to aid with the use of indirection objects.

The global \_\_pul\_eval procedure expects an object on the stack, pops it, and pushes the fully-evaluated form. If the object is not an indirection object, it is left intact. Otherwise, the fully-evaluated form is pushed.

When an identifier is encountered in PUL, it evaluates at any depth, not just the within current function context. To enable this, there is a global procedure, \_\_pul\_var, which recurses through the parents of the current object until one containing the desired member is found. It's used after the object and member name have been pushed, but before the \textit{member} operation, e.g.

\begin{verbatim}
this “foo” global “\_\_pul\_var” member call member
\end{verbatim}

Finally, there are several global functions to automatically convert functions and values to indirect objects. They are documented in pul.plof.



\subsection{Calling Convention}

The arguments to a function are pushed onto the stack as an array. The function is expected to pop all of its local variables and the arguments, and push its return value. If it doesn't return a value, it should still push something, usually a null.



\section{Language}

PUL is an extremely dynamic impure functional language with support for the imperative paradigm. Although imperative programming is well-supported, the language is lazy. The laziness, however, is diminished by the presence of statements and immediate assignment.

The object system of PUL is prototype-based, but with additional properties allowing it to be used with annotations. This will be discussed in a later section.



\subsection{Grammar}

The following is the grammar of PUL, roughly in BNF form. The 'white' keyword which parses whitespace in the master grammar has been removed; suffice to say that the grammar parses whitespace before every token, as in C. Statements are terminated by a newline or semicolon. Whitespace elements in PUL are space, tab, carriage return, line feed and C-style and C++-style comments.

The following is the base grammar as created by \texttt{pul\_g.plof} and \texttt{object\_g.plof}; other extensions to the grammar added by the standard library will be covered in later sections.



\begin{verbatim}
    top => plof_statement

    plof_statement = plof_statement_next eos
    plof_statement => plof_assign

    // allow Plof in PSL
    pslOp = "plof"w "\{"w plof_semicolon "\}"w

    plof_semicolon = plof_semicolon eos plof_semicolon_next
    plof_semicolon = plof_semicolon eos
    plof_semicolon = plof_semicolon_next
    plof_semicolon => plof_assign

    plof_assign = plof_assign_next "="w plof_assign
    plof_assign = plof_assign_next
    plof_assign => plof_bind

    plof_bind = "let"w plof_bind_next "="w plof_bind
    plof_bind = plof_bind_next
    plof_bind => plof_group

    plof_group = "forceEval"w "\("w plof_identifier "\)"

    plof_group = plof_group "\."w plof_identifier
    plof_group = plof_group "\."w "parent"
    plof_group = plof_group_next
    plof_group => plof_parens

    plof_parens = "\("w plof_semicolon "\)"
    plof_parens = plof_parens_next
    plof_parens => plof_literal

    // none of these literals are actually literals (hm), but they're at the same precedence
    plof_literal = "psl"w "\{"w pslOps "\}"
    plof_literal = /\$/ number nnlwhite
    plof_literal = plof_literal_next
    plof_literal => plof_var

    plof_var = "var"w plof_identifier
    plof_var = plof_var_next
    plof_var => plof_ident

    plof_ident = plof_identifier

    plof_identifier = plof_notkeyword /[A-Za-z_][A-Za-z0-9_]*/ token nnlwhite

    plof_notkeyword =
        /()(?!as[^A-Za-z0-9_])/
        /()(?!by[^A-Za-z0-9_])/
        /()(?!forceEval[^A-Za-z0-9_])/
        /()(?!is[^A-Za-z0-9_])/
        /()(?!in[^A-Za-z0-9_])/
        /()(?!include[^A-Za-z0-9_])/
        /()(?!parent[^A-Za-z0-9_])/
        /()(?!return[^A-Za-z0-9_])/
        /()(?!rtInclude[^A-Za-z0-9_])/
        /()(?!to[^A-Za-z0-9_])/
        /()(?!var[^A-Za-z0-9_])/

    plof_group = plof_group plof_group_next

    plof_group = plof_group "\("w plof_args "\)"


    plof_args = white

    plof_args = plof_args_prime

    plof_args_prime = plof_args_prime ","w plof_args_prime_next

    plof_args_prime = plof_args_prime_next ","w plof_args_prime_next

    plof_args_prime => plof_arg

    plof_arg = plof_semicolon

    plof_group = "\("w plof_params "\)" "\{"w plof_funcbody "\}"
    
    plof_params = white

    plof_params = plof_params ","w plof_params_next

    plof_params = plof_params_next

    plof_params => plof_param

    plof_param = plof_identifier

    plof_funcbody = white
    plof_funcbody = plof_funcbody_next
    plof_funcbody => plof_funcbody_prime

    plof_funcbody_prime = plof_semicolon


    // deep returns
    plof_group = "return"w plof_group_next

    plof_group = "\{"w plof_funcbody "\}"

    plof_obj_def = "this"w plof_bind_next

    plof_literal = "ref"w plof_var
\end{verbatim}



\subsection{Basic Syntax}

PUL's statements and expressions resemble those in most C-style languages. Statements are terminated by ';', and of course any number of statements may be listed consecutively. The precedence of all of the operators is described in the above grammar. Statements are implemented in a functional style; that is, semicolon-separated statements really just form an expression, and evaluation of that expression will result in evaluation of the left and right sides in order, evaluating to the value of the right side.

Because PUL is lazy, several constructs have special meanings to allow eager evaluation. Statements are always evaluated eagerly, although the resultant value is not used. Note however that this does \textit{not} mean that every value used in the statement is evaluated. Whatever is necessary to attain a final value of the expression is evaluated, and that final value is discarded. The right-hand side of an assignment expression is also evaluated eagerly. All other cases are evaluated lazily, including notably arguments to functions.



\subsection{Variables}

Variables may declared within any context with the \texttt{var} keyword. When first defined, a variable will have the value \textit{null}, so a \texttt{var} expression may be used as an l-value or an r-value. Variables may not be used without being declared. Variable assignment uses the '=' operator as in C-family languages, but '=' returns void, so chains like \texttt{a = b = c} do not function as they do in most C-family languages.



\subsection{Objects}

PUL's objects are always derived from other objects, with the exception of the object named “Object”, which is the top of the object hierarchy and is defined in PSL. As well as being the top of the hierarchy, Object defines all of the basic operators. All operators on Object throw exceptions (described in a later section), with the exception of '==' and '!=', which simply compare object references if not overloaded.



\subsection{Operator Overloading}

Most operators in Plof are defined to call functions on their objects (the only exceptions are '.', '=', ',' and ';'), and so can be overloaded with user code. The following table describes operators and the equivalent function call.

\LTXtable{\linewidth}{operatorFunctions.tex}

Several operators have default implementations which use auxiliary functions, to allow users to implement many operators with only one function. These default implementations are all part of Object, and the auxiliary functions throw exceptions as with all default operator definitions. The equivalences are:

\LTXtable{\linewidth}{operatorEquivalents.tex}

All operator functions are defined in Object, so all objects have defined operators, but most of them are defined in Object simply to throw an exception (the exception mechanism will be discussed later).

\texttt{opEqual} and \texttt{opNotEqual} check object identity in Object, but should be overloaded in any code with a well-defined equality operation. \texttt{opIs} implements type-checking, which will be described further in the next section.



\subsection{Object Syntax}

Objects are defined by the syntax \texttt{Super : [...]}, where 'Super' is the parent type (which must always be specified, even if it is Object), and '...' is the content of the object. Any fields given in the object definition will override those defined by the parent. Fields are specified by semicolon-separated assignment statements, e.g.:

\begin{verbatim}
var O = Object : [
    x = 3;
    y = 4;
]
\end{verbatim}



Fields may be functions (the syntax of which is defined later), creating methods, but methods are in no other way different from other fields. Field definitions may refer to previous fields but not later ones, as the fields will be evaluated in the order that they appear.

>Every object contains a special field, \texttt{\_\_pul\_type}, which contains an array of objects which this object is derived from, then itself. The ordering of \texttt{\_\_pul\_type} is well-defined, as an object definition will always simply append one element to the \texttt{\_\_pul\_type} of the parent. \texttt{opIs} implements type-checking by simply comparing its parameter with every element in \texttt{\_\_pul\_type}. If any match, the type-check succeeds.



\subsection{Multiple Inheritance}

As well as defining new objects, it is also possible to combine existing objects. The syntax is the same, with the exception that \texttt{[...]} is replaced by the second object. Important to note is that operators defined by Object will usually not be handled well by multiple inheritance: If for example the left object implements opAnd but not opAdd, and the right object implements opAdd but not opAnd, the resultant object will implement opAdd but not opAnd, as it will inherent the right-hand object's default opAnd.



\subsection{Field Ownership}

Every object has a parent object, as defined by PSL. Fields of objects may point to children of the object, or any other object. These cases are treated differently when objects are combined. If a field contains a child object, that object will be duplicated in the process of duplicating the parent object, and the resultant child object's parent will be the resultant parent object (the result of combination). If a field contains a non-child object (an object with a parent of any other object), it is not duplicated, but the appropriate field in the new object is simply set as another reference to the same object.



\subsection{Prototypes}

PUL has no inherent way to distinguish prototype objects (objects intended only to be derived from into other objects) and instance objects (objects meant to be used in program logic). However, to make the distinction convenient for users, a \texttt{new} function is provided by the core library. \texttt{new} takes an object assumed to be a prototype, duplicates it (\texttt{o : []}), and calls an optional 'init' function on the resultant object.



\subsection{Functions}

Functions in PUL are first-class, and are in fact objects (the Function object is derived from Object, and all functions are derived from Function). The fundamental PSL procedure associated with a function is simply the raw data that the object contains, so calling a function is, at the PSL level, just a primitive \textit{call}. The context of functions is the parent of the function object, which results generally in lexical scoping (functions declared in a scope will have that scope as their parent), but is modifiable to allow any form of dynamic scoping.



\subsection{Function Syntax}

In the simplest form, functions in PUL are in the form \texttt{\{...\}} , with ``...'' being the expression defining the function. All functions are defined in this way, there is no distinction between lambda functions and named functions. That is, a named function is just an anonymous function assigned to a variable:

\begin{verbatim}
var evalToOne = { 1 }
\end{verbatim}



\subsection{Parameters}

Functions may have parameters, specified by a comma-separated list of variable names all within parenthesis ('(' and ')') preceding the function:

\begin{verbatim}
var addOne = (x) { x + 1 }
\end{verbatim}



Parameters may be type-checked by using 'as':

\begin{verbatim}
var addOne = (x as Integer) { x + 1 }
\end{verbatim}

This is implemented with \texttt{opAs} , and an exception is thrown if \texttt{opAs} fails.



\subsection{Provided Objects}

The PUL runtime environment provides a large number of builtin objects, serving as prototypes for classes such as \texttt{Integer} and \texttt{Boolean} . The runtime environment and provided objects will be described in a later version of this specification, as they have not yet been completely defined.
