\setlength{\pdfpageheight}{\paperheight}
\setlength{\pdfpagewidth}{\paperwidth}


\begin{document}
\ifdefined\specdocheader
    \specdocheader
\else\fi

\begin{titlepage}
\begin{center}

\Huge{\textsf{Plof Language Specification}}

\small{This specification is not yet complete.\\It is available in Plof's mercurial repository, at \texttt{https://codu.org/plof/hg/}.}

\Large{\textsf{Revision \input{hgversion.tex}}}

\large{\input{hgdate.tex}}

\end{center}
\end{titlepage}

\tableofcontents

\chapter{Overview}

Plof is composed of a user-visible language which is parsed and compiled dynamically to a bytecode. An implementation of Plof must only support the bytecode and the flexible parsing framework; the user language is built entirely from Plof code.

The virtual machine runs a simple bytecode stack language, called the Plof Stack Language, or PSL, and code in the user language (the Plof User Language or simply Plof) is compiled using a runtime-defined grammar into PSL code. This specification will cover the details of PSL first. PSL is intended to be low-level and highly generatable, but also analyzable and optimizable.

The intermediary layer between these two is the Plof Runtime Parser (PRP), which is a flexible parsing and compiling framework, allowing the grammar being parsed and output code to be changed dynamically, at runtime. This allows Plof to be an extremely flexible language, with new features added to the language proper by libraries.

Plof, or the Plof User Language (PUL), is a minimalistic prototype-based object-oriented general-purpose programming language. Its syntax is inspired by C, Java, Tcl, Haskell and JavaScript, but its semantics are unique, although resembling JavaScript in some ways. Although an implementor of Plof must understand this entire document, the average user of Plof needs no knowledge of PSL or the parser.

\input{psl.tex}
\input{prp.tex}
\input{pul.tex}
\input{appendices.tex}

\end{document}
