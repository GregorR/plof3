/*
 * The standard Plof collection class, ported from Plof2.
 *
 *  Copyright (c) 2007, 2008  Gregor Richards
 *  Copyright (c) 2007, 2008  Josiah Worcester
 *  
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the "Software"), to
 *  deal in the Software without restriction, including without limitation the
 *  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 *  sell copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *  
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *  
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 *  IN THE SOFTWARE.
 */

var Collection = Object : [
    NilElement = Object : [];

    each = (x as Function) {
        Abstract();
    };

    dup = {
        Abstract();
    };

    apply = (x as Function) {
        Abstract();
    };

    map = (x){
        dup().apply(x);
    };

    size = {
        var i = 0;
        each((x){i++});
        return(i);
    };

    fold = (init, f as Function) {
        var ret = init;
        each((x){ret = f(ret,x)});
        return(ret);
    };

    sum = {
        fold(0, (x, y){x+y})
    };

    product = {
        fold(0, (x, y){x*y})
    };
];

var IndexableCollection = Collection : [
    opIndex = (x as Number) {
        Abstract();
    };
];

var Array = IndexableCollection : [
    opIndex = (x as NativeNumber) {
        psl {
            // make an indirection object, since this is an lval
            new

            // __pul_e first
            push0 "__pul_e"
            {
                this "this" pul_var member pul_eval
                this "x" pul_var member pul_eval
                     "__value" member pul_eval
                index
            } memberset

            // __pul_s is mostly similar, but with a set
            push0 "__pul_s"
            {
                this "this" pul_var member pul_eval
                this "x" pul_var member pul_eval
                     "__value" member pul_eval
                push2 indexset pop
            } memberset
        }
    };

    each = (x) {
        for(var i = 0, i < size(), i = i + 1, (
            x(this[i]);
        ));
    };

    opContains = (x) {
        var ret = False;
        each((y) {
            if((x == y), (
                ret = True;
            ));
        });
        return(ret);
    };

    dup = {
        this:[];
    };

    apply = (x as Function) {
        for(var i = 0, i < size(), i = i + 1, (
            this[i] = x(this[i]);
        ));
    };

    size = {
        psl {
            this "this" pul_var member pul_eval
            length

            // then use opNumber to number-ize it
            1 integer array
            this "opNumber" pul_var member pul_eval call
        }
    };
];

// The function to convert a primitive array to an Array
var opArray = (x) {
    Array:x
};

// Create a new array from a list of parameters
var array = {
    var i = 0;
    var res = psl {
        0 integer array 1 integer array
        this "opArray" pul_var member pul_eval call pul_eval
    };

    // this is complicated because we want to guarantee that e is evaluated
    args.each((e) {
        res[i] = e;
    });

    return(res);
};
