/*
 * Basic members of Object and Function
 *
 *  Copyright (c) 2008, 2009  Gregor Richards
 *  
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the "Software"), to
 *  deal in the Software without restriction, including without limitation the
 *  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 *  sell copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *  
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *  
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 *  IN THE SOFTWARE.
 */

// opMember is not a capital-F Function, as that would be a recursive definition (opMember.opMember.opMember...)
Object.opMember = psl { {
    // args: [name, next context]
    this "name" push2 0 integer index pul_eval memberset
    this "next" push2 1 integer index pul_eval memberset

    // first check if it's in "this"
    null this "this" resolve member this "name" member member null
    {
        // it's not here, try the type
        this "type" this "__pul_type" resolve member memberset
        this "index" 1 integer memberset

        null
        {
            {
                // continue so long as the index is < the length
                this "index" resolve member
                this "type" resolve member length
                { global } { null } lt
            }
            {
                // OK, check if that type has this
                this "type" resolve member
                    this "index" resolve member
                        index
                
                    push0 this "name" resolve member member null
                    {}
                    {
                        // found it, get it
                        push0 this "name" resolve member member 

                        // then duplicate it
                        1 integer array
                        this "opDuplicate" resolve member call

                        // reparent it
                        push0 this "this" resolve member parentset

                        // and assign it into us
                        this "this" resolve member this "name" resolve member push2 memberset

                        // now make it a reference
                        this "this" resolve member this "name" resolve member pul_varwrap

                        // then throw it
                        new
                        push0 "__pul_opmember_search" push3 memberset
                        throw
                    } cmp

                    pop

                // now increment the index
                this "index" resolve
                        this "index" resolve member
                            1 integer add
                            memberset
            } while pop

            // didn't find it. Check with the next guy
            this "name" resolve member "opMember"
            this "next" resolve member
            push2 push2 2 integer array resolve
            4 integer array

            // now check whether we used opMember or the name
            push0 1 integer index
            push1 3 integer index
            {
                // used opMember, call it
                push0 0 integer index
                push1 2 integer index parent 2 integer array
                push1 2 integer index "opMember" member pul_eval call
            }
            {
                // no opMember
                push0 2 integer index
                push1 0 integer index
                member
            } cmp
        }
        {
            // is this our response?
            push0 "__pul_opmember_search" member null
            {
                // no, throw it again
                throw
            }
            {
                // yes, just pass it along
                "__pul_opmember_search" member
            } cmp
        } catch
    }
    {
        // we have it, simple enough
        this "this" resolve member
        this "name" resolve member
        pul_varwrap
    } cmp
} };
psl { this "Object" resolve member push0 "opMember" member push1 parentset pop };


// the Function type
var Function = Object : [];


// FIXME: Should use proper combination
var opFunction = Function:psl { {
    // get the procedure
    this "proc" push2 0 integer index pul_eval memberset

    // combine it with Function
    plof { Function:proc } pul_eval
} };


/// The Plof version of psl{null}
var Null = Object:[];


/// Some useful functions
var selff = (x) { selff };
var id = (x) { x };


/// Standard object initialization
var new = (type) {
    (type:[]).init
};
Object := [init = {this};];


/// References
var Reference = Object : [
    this (readx, writex) {
        this.read = readx;
        this.write = writex;
    };
];
