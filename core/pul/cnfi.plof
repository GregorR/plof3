/*
 * Interface for the C Native Function Interface
 *
 *  Copyright (c) 2008, 2009  Gregor Richards
 *  
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the "Software"), to
 *  deal in the Software without restriction, including without limitation the
 *  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 *  sell copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *  
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *  
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 *  IN THE SOFTWARE.
 */

// the psl operations
pslbnf {
    pslOp = "dlopen" =>     { 193 byte }
    pslOp = "dlclose" =>    { 194 byte }
    pslOp = "dlsym" =>      { 195 byte }
    pslOp = "cmalloc" =>    { 196 byte }
    pslOp = "cfree" =>      { 197 byte }
    pslOp = "cget" =>       { 198 byte }
    pslOp = "cset" =>       { 199 byte }
    pslOp = "ctype" =>      { 200 byte }
    pslOp = "cstruct" =>    { 201 byte }
    pslOp = "csizeof" =>    { 202 byte }
    pslOp = "csget" =>      { 203 byte }
    pslOp = "csset" =>      { 204 byte }
    pslOp = "prepcif" =>    { 205 byte }
    pslOp = "ccall" =>      { 206 byte }
}

// and their Plof equivalents
var C = Object : [
    dlopen = (filename as String) {
        psl {
            plof{filename.__pul_val} pul_eval
            dlopen
            push0 null
            { plof{Null} }
            {
                1 array
                plof{opCPointer} pul_eval call
            } cmp
        }
    }

    dlclose = (handle as CPointer) {
        psl {
            plof{handle.__pul_val} pul_eval
            dlclose null
        }
    }

    dlsym = (handle as CPointer, symbol as String) {
        psl {
            plof{handle.__pul_val} pul_eval
            plof{symbol.__pul_val} pul_eval
            dlsym
            push0 null
            { plof{Null} }
            {
                1 array
                plof{opCPointer} pul_eval call
            } cmp
        }
    }

    malloc = (sz as NativeInteger) {
        opCPointer(psl {
            plof{sz.__pul_val} pul_eval
            cmalloc
        })
    }

    free = (ptr as CPointer) {
        psl {
            plof{ptr.__pul_val} pul_eval
            cfree null
        }
    }

    get = (ptr as CPointer, sz as NativeInteger) {
        var ret = CData : []
        ret.__pul_val = psl {
            plof{ptr.__pul_val} pul_eval
            plof{sz.__pul_val} pul_eval
            cget
        }
        return(ret)
    }

    set = (ptr as CPointer, value) {
        psl {
            plof{ptr.__pul_val} pul_eval
            plof{value.__pul_val} pul_eval
            cset null
        }
    }

    sizeof = (type as NativeInteger) {
        opInteger(psl {
            plof{type.__pul_val} pul_eval
            csizeof
        })
    }

    prepcif = (rtype as NativeInteger, atypes as Array, abi as NativeInteger) {
        // extract the values out of the types array
        var nat = psl { 0 array }
        var elem
        atypes.each (ref elem) (
            nat = psl {
                plof{nat} pul_eval
                plof{elem.__pul_val} pul_eval
                1 array aconcat
            }
        )

        // and call prepcif
        return(opCPointer(psl {
            plof{rtype.__pul_val} pul_eval
            plof{nat} pul_eval
            plof{abi.__pul_val} pul_eval
            prepcif
        }))
    }

    call = (cif as CPointer, fn as CPointer, cargs as Array) {
        // extract the values out of the args array
        var nargs = psl { 0 array }
        var elem
        cargs.each (ref elem) (
            nargs = psl {
                plof{nargs} pul_eval

                // elem as CData
                /* FIXME
                this "CData" pul_var member pul_eval 1 array
                this "elem"  pul_var member pul_eval "opAs" member call
                "__pul_val" member */
                plof{elem.__pul_val} pul_eval

                // combine them
                1 array aconcat
            }
        )

        // then call
        var ret = CData:[]
        ret.__pul_val = psl {
            plof{cif.__pul_val} pul_eval
            plof{fn.__pul_val} pul_eval
            plof{nargs} pul_eval
            ccall
        }
        return(ret)
    }

    // types
    void = opInteger(psl { 0 ctype })
    int = opInteger(psl { 1 ctype })
    float = opInteger(psl { 2 ctype })
    double = opInteger(psl { 3 ctype })
    longdouble = opInteger(psl { 4 ctype })
    uint8 = opInteger(psl { 5 ctype })
    int8 = opInteger(psl { 6 ctype })
    uint16 = opInteger(psl { 7 ctype })
    int16 = opInteger(psl { 8 ctype })
    uint32 = opInteger(psl { 9 ctype })
    int32 = opInteger(psl { 10 ctype })
    uint64 = opInteger(psl { 11 ctype })
    int64 = opInteger(psl { 12 ctype })
    pointer = opInteger(psl { 14 ctype })
    uchar = opInteger(psl { 24 ctype })
    schar = opInteger(psl { 25 ctype })
    ushort = opInteger(psl { 26 ctype })
    short = opInteger(psl { 27 ctype })
    uint = opInteger(psl { 28 ctype })
    ulong = opInteger(psl { 30 ctype })
    long = opInteger(psl { 31 ctype })
    ulonglong = opInteger(psl { 32 ctype })
    longlong = opInteger(psl { 33 ctype })
]


// the type of pointers from dlopen/dlsym/etc
var CPointer = Object : [
    init = (x) {
        this.__pul_val = x
        return this
    }

    opCastFrom = (x) {
        if (x is Null) (
            return (new CPointer(psl { null }))
        ) else (
            return Null
        )
    }
]
var opCPointer = (x) {
    new CPointer(x)
}

// a pseudotype containing raw data for C
var CData = Object : [
    opCastFrom = (x) {
        if (x is Number) (
            // it already has __pul_val, so accept it as-is
            return(this : (x as NativeInteger))
        ) else if (x is String) (
            return(this : (x as String))
        ) else (
            return(Null)
        )
    }

    opCastTo = (x) {
        if (x is Number) (
            // this already has __pul_val, so accept it as-is
            return(this : NativeInteger)
        ) else if (x is String) (
            return(this : String)
        ) else if (x is CPointer) (
            return(this : CPointer)
        ) else (
            return(Null)
        )
    }
]

// convenient wrappers
C.calloc_s = C.dlsym(Null, "calloc")
C.calloc_c = C.prepcif(C.pointer, [[C.pointer, C.pointer]], 0)
C.calloc = (x as NativeInteger) {
    C.call(C.calloc_c, C.calloc_s, [[x, 1]]) as CPointer
}
C.strlen_s = C.dlsym(Null, "strlen")
C.strlen_c = C.prepcif(C.pointer, [[C.pointer]], 0)
C.strlen = (x as CPointer) {
    C.call(C.strlen_c, C.strlen_s, [[x]]) as Number
}

C.getstr = (x as CPointer) {
    var l = C.strlen(x)
    C.get(x, l) as String
}

// things that need CNFI
C.exit_s = C.dlsym(Null, "exit")
C.exit_c = C.prepcif(C.pointer, [[]], 0)
var exit = () {
    C.call(C.exit_c, C.exit_s, [[]])
}
