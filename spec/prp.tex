\chapter{Plof Runtime Parser}

Plof code is parsed and compiled by productions created at runtime. A production is a name, an array of targets, and PSL code to run when the production is parsed. Targets may be nonterminals (productions) or regular expressions. The PSL code should produce a raw data object, itself containing PSL code (the compiled result of the production), and is run with the results of each of the targets in an array as the argument.

Multiple productions may be created with the same name, which indicates that the nonterminal corresponds to a choice of any of the productions.

The following example productions correspond to a simple arithmetic language:

\begin{verbatim}
mul = mul /\*/ add => { push0 0 index push1 2 index concat {mul} concat }
mul = add => { push0 0 index }
add = add /\+/ digit => { push0 0 index push1 2 index concat {add} concat }
add = digit => { push0 0 index }
\end{verbatim}

The parser must support self-referencing left-recursive productions such as \texttt{A = A /b/}, but not more complex left-recursive productions such as \texttt{A = B /b/ ; B = A /a/}.

Regular expression targets will parse greedily. If they contain any parenthesized parts, they will consume only up to the end of the first parenthesized part, otherwise the entire matching substring is consumed. The result of a regular expression, returned to the production using it, is PSL code to produce the consumed string as a raw data object. Because the parser's terminals are regular expressions, no tokenization step is necessary in parsing.

The Plof interpreter parses code by repeatedly applying the production named ``top'' to the remaining input code. As such, the ``top'' production should parse one top-level statement or declaration of the target language. The interpreter's grammar should contain no productions at startup, so precompiled PSL code is required to initialize the parser.
