/*
 * The Plof User Language basic definitions. This file gets you from the grammar defined in base.psl
 * to a functional PUL grammar, and creates mostly-empty Object and Function objects. object.pul
 * should be loaded next to flesh out the important objects.
 *
 *  Copyright (c) 2007, 2008  Gregor Richards
 *  
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the "Software"), to
 *  deal in the Software without restriction, including without limitation the
 *  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 *  sell copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *  
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *  
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 *  IN THE SOFTWARE.
 */

// Basic PSL: psl { psl code here };
__grammar_add(top, psl, push0 0 integer index);
__grammar_add(psl,
              white /psl/ token white /\{/ white pslOps /\}/ white /;/ white,
              push0 6 integer index);

// PSL BNF: pslbnf { production = target => { code } };
__grammar_add(top, pslbnf, push0 0 integer index);
__grammar_add(pslbnf,
              white /pslbnf/ token white /\{/ white pslbnf_productions /\}/ white /;/ white,
              push0 6 integer index {[gcommit]} concat);
__grammar_add(pslbnf_productions,
              pslbnf_productions pslbnf_production,
              push0 0 integer index push1 1 integer index concat);
__grammar_add(pslbnf_productions,
              pslbnf_production,
              push0 0 integer index);
__grammar_add(pslbnf_production,
              /[A-Za-z_][A-Za-z0-9_]*/ white /=/ white pslbnf_targets
                  /=>/ white /\{/ white pslOps /\}/ white,
              push0 0 integer index
                  push1 4 integer index
                  push2 9 integer index cwrap
                  {gadd}
                  concat concat concat iwrap);
__grammar_add(pslbnf_production,
              /[A-Za-z_][A-Za-z0-9_]*/ white /=>/ white /[A-Za-z_][A-Za-z0-9_]*/ white /;/ white,

              // set that->next to this->next, then this->next to that

              {global} "grammar_" null push3 0 integer index call concat "_next" concat swrap concat {member} concat
              // inner stack: global.grammar_<this>_next
              {global} concat "grammar_" null push3 4 integer index call concat "_next" concat swrap concat
              // inner stack: global.grammar_<this>_next global "grammar_<that>_next"
              {push2 memberset} concat
              // inner stack: global.grammar_<this>_next

              null push2 4 integer index call "_next" concat swrap concat
              {push0 grem} concat
              // inner stack: global.grammar_<this>_next "<that>_next"
              {push1 1 integer array {push0 0 integer index} gadd pop} concat
              // inner stack:

              // now this->next = that
              push1 4 integer index concat
              // inner stack: "<that>"
              {global} concat "grammar_" null push3 0 integer index call concat "_next" concat swrap concat
              // inner stack: "<that>" global "grammar_<this>_next"
              {push2 memberset} concat
              // inner stack: "<that>"

              null push2 0 integer index call "_next" concat swrap concat
              {push0 grem} concat
              // inner stack: "<that>" "<that>_next"
              {push1 1 integer array {push0 0 integer index} gadd pop} concat
              // inner stack:

              // wrap it all up in an immediate
              iwrap);
__grammar_add(pslbnf_targets,
              pslbnf_targets pslbnf_target,
              push0 0 integer index
                  push1 1 integer index
                  {aconcat}
                  concat concat);
__grammar_add(pslbnf_targets,
              pslbnf_target,
              push0 0 integer index);
__grammar_add(pslbnf_target,
              /[A-Za-z_][A-Za-z0-9_]*/ token white,
              push0 0 integer index
                  {1 integer array}
                  concat);
__grammar_add(pslbnf_target,
              /(\/([^\\\/]*\\.)*[^\\\/]*\/)/ token white,
              push0 0 integer index
                  {1 integer array}
                  concat);

__grammar_add(pslbnf_target,
              /"/ /[A-Za-z0-9_]+/ /"/ white,
              // force this to be its own token production in the grammar
              null push1 1 integer index call

              // get the name of the production
              "token_" push1 concat swrap

              // remove it if it already exists
              {push0 push0 grem} concat

              // now make the regex
              "/"
              push2 concat
              "/" concat
              swrap concat

              // and gadd it
              {
                  "token" "white" 3 integer array
                  {push0 0 integer index}
                  gadd
                  1 integer array
              } concat);

__grammar_add(pslbnf_target,
              /"/ /([^A-Za-z0-9_]([^\\\/"]*\\.)*[^\\\/"]*)/ /"/ white,
              // force this to be its own token production in the grammar
              null push1 1 integer index call

              // get the name of the production
              "token_" push1 concat swrap

              // remove it if it already exists
              {push0 push0 grem} concat

              // now make the regex
              "/"
              push2 concat
              "/" concat
              swrap concat

              // and gadd it
              {
                  "white" 2 integer array
                  {push0 0 integer index}
                  gadd
                  1 integer array
              } concat);

__grammar_commit();

psl {
    /* PUL objects can potentially be unevaluated. This function evaluates
     * unevaluated objects, or just returns the object if it has been evaluated */
    global "__pul_eval" {
        // is __pul_v set?
        push0 "__pul_v" member null
        {
            // no __pul_v, how 'bout __pul_e?
            push0 "__pul_e" member null
            {
                // neither, it's just a value
            }
            {
                // __pul_e is set, call it
                null push1 "__pul_e" member call
                global "__pul_eval" member call
            } cmp
        }
        {
            // __pul_v is set, use it
            "__pul_v" member
            global "__pul_eval" member call
        } cmp
    } memberset

    global "__pul_forceEval" {
        // is __pul_e set?
        push0 push0 "__pul_e" member null
        {
            // neither, it's just a value
        }
        {
            // call __pul_e
            null push1 "__pul_e" member call
            global "__pul_eval" member call
        } cmp
    } memberset

    // PUL returns are by-ref, so you can set through them. __pul_set does so
    global "__pul_set" {
        // arg: [byref object, new value]

        // make sure __pul_s is set
        push0 0 integer index "__pul_s" member null
        {
            // not set: This should be handled better (FIXME)
        }
        {
            // OK, set it
            push0 1 integer index
            push1 0 integer index "__pul_s" member call
        } cmp
    } memberset

    // create an unevaluated value from a procedure
    global "__pul_funcwrap" {
        // arg: procedure

        // put the procedure in a variable
        this "proc" push2 memberset

        // then make an object
        new

        // first, __pul_e
        push0 "__pul_e" {
            null this "proc" resolve member call
            global "__pul_eval" member call
        } memberset

        // then __pul_s
        push0 "__pul_s" {
            null this "proc" resolve member call
            push1 2 integer array
            global "__pul_set" member call
        } memberset
    } memberset

    // create an unevaluated value from a variable
    global "__pul_varwrap" {
        // arg: [context, name]

        // put the argument in a var
        this "arg" push2 memberset

        // then make an object
        new

        // first, __pul_e
        push0 "__pul_e" {
            this "arg" resolve member
            push0 0 integer index

            // check if we have it directly
            push1 1 integer index member null
            {
                // OK, maybe opMember?
                push0 0 integer index
                "opMember" member null
                {
                    // neither: Fail
                    null
                }
                {
                    // use opMember
                    push0 1 integer index null 2 integer array
                    push1 0 integer index "opMember" member
                    global "__pul_eval" member call
                    call
                } cmp
            }
            {
                // have it directly, easy
                push0 0 integer index
                push1 1 integer index
                member
            } cmp
        } memberset

        // then, __pul_s
        push0 "__pul_s" {
            this "arg" resolve member
            push0 0 integer index
            push1 1 integer index
            push3
            memberset
        } memberset
    } memberset

    // create an unevaluated value for the parent of an object
    global "__pul_parentwrap" {
        // arg: object

        // put the argument in a var
        this "obj" push2 memberset

        // then make an object
        new

        // first, __pul_e
        push0 "__pul_e" {
            this "obj" resolve member
            parent
        } memberset

        // then, __pul_s
        push0 "__pul_s" {
            this "obj" resolve member
            push1
            parentset
        } memberset
    } memberset


    // PUL functions are marked with the variable __pul_fc. This finds it
    global "__pul_fcontext" {
        // arg: context
        "__pul_fc" resolve pop
    } memberset
};

// some convenient pseudo-ops
pslbnf {
    pslOp = "pul_eval" => {
        {global "__pul_eval" member call}
    }

    pslOp = "pul_forceEval" => {
        {global "__pul_forceEval" member call}
    }

    pslOp = "pul_set" => {
        {2 integer array global "__pul_set" member call pop}
    }

    pslOp = "pul_funcwrap" => {
        {global "__pul_funcwrap" member call}
    }

    pslOp = "pul_varwrap" => {
        {2 integer array global "__pul_varwrap" member call}
    }

    pslOp = "pul_parentwrap" => {
        {global "__pul_parentwrap" member call}
    }

    pslOp = "pul_fcontext" => {
        {this global "__pul_fcontext" member call}
    }
};

// the base PUL grammar
pslbnf {
    top = white top_next => { push0 1 integer index }
    top => plof_statement;

    plof_statement = plof_statement_next ";" => {
        push0 0 integer index {pul_eval pop} concat
    }
    plof_statement => plof_assign;

    // allow Plof in PSL
    pslOp = "plof" "\{" plof_semicolon "\}" => {
        push0 2 integer index
    }

    plof_semicolon = plof_semicolon ";" plof_semicolon_next => {
        push0 0 integer index {pul_eval pop} concat
        push1 2 integer index concat
        cwrap {pul_funcwrap} concat
    }
    plof_semicolon = plof_semicolon ";" => {
        push0 0 integer index {pul_eval pop this "Null" resolve member} concat
        cwrap {pul_funcwrap} concat
    }
    plof_semicolon = plof_semicolon_next => { push0 0 integer index }
    plof_semicolon => plof_assign;

    plof_assign = plof_assign_next "=" plof_assign => {
        push0 2 integer index
        push1 0 integer index concat
        {push1 pul_eval pul_set} concat
        cwrap {pul_funcwrap} concat
    }
    plof_assign = plof_assign_next => { push0 0 integer index }
    plof_assign => plof_bind;

    plof_bind = "let" plof_bind_next "=" plof_bind => {
        push0 3 integer index
        push1 1 integer index concat
        {push1 pul_set} concat
        cwrap {pul_funcwrap} concat
    }
    plof_bind = plof_bind_next => { push0 0 integer index }
    plof_bind => plof_group;

    plof_group = "forceEval" "\(" plof_group "\)" => {
        push0 2 integer index
        {pul_forceEval} concat
        cwrap {pul_funcwrap} concat
    }

    plof_group = plof_group "\." plof_identifier => {
        push0 0 integer index
        {pul_eval} concat
        push1 2 integer index concat
        {pul_varwrap} concat
        cwrap {pul_funcwrap} concat
    }
    plof_group = plof_group "\." "parent" => {
        push0 0 integer index
        {pul_eval pul_parentwrap} concat
        cwrap {pul_funcwrap} concat
    }
    plof_group = plof_group_next => { push0 0 integer index }
    plof_group => plof_parens;

    plof_parens = "\(" plof_semicolon "\)" => {
        push0 1 integer index
    }
    plof_parens = plof_parens_next => { push0 0 integer index }
    plof_parens => plof_literal;

    // none of these literals are actually literals (hm), but they're at the same precedence
    plof_literal = "psl" "\{" pslOps "\}" => {
        push0 2 integer index
        cwrap {pul_funcwrap} concat
    }
    plof_literal = /\$/ number token white => {
        null push1 1 integer index call
        integer
        "ü" wrap
    }
    plof_literal = plof_literal_next => { push0 0 integer index }
    plof_literal => plof_var;

    plof_var = "var" plof_identifier => {
        {pul_fcontext}
        push1 1 integer index concat
        {push1 push1 this "Null" resolve member memberset pul_varwrap} concat
        cwrap {pul_funcwrap} concat
    }
    plof_var = plof_var_next => { push0 0 integer index }
    plof_var => plof_ident;

    plof_ident = plof_identifier => {
        // the name we're actually looking for
        push0 0 integer index

        // use opMember if possible
        {
            "opMember"

            // look in the current function context
            this push2 push2 2 integer array resolve
            4 integer array

            // now check whether we used opMember or the name
            push0 1 integer index
            push1 3 integer index
            {
                // used opMember: args = [name, next context]
                push0 0 integer index
                push1 2 integer index parent 2 integer array
                push1 2 integer index "opMember" member pul_eval call
            }
            {
                // no opMember
                push0 2 integer index
                push1 0 integer index
                pul_varwrap
            } cmp
        } concat

        // wrap it up
        cwrap {pul_funcwrap} concat
    }

    plof_identifier = plof_notkeyword /[A-Za-z_][A-Za-z0-9_]*/ token white => {
        push0 1 integer index
    }

    plof_notkeyword =
        /()(?!as[^A-Za-z0-9_])/
        /()(?!forceEval[^A-Za-z0-9_])/
        /()(?!is[^A-Za-z0-9_])/
        /()(?!in[^A-Za-z0-9_])/
        /()(?!include[^A-Za-z0-9_])/
        /()(?!parent[^A-Za-z0-9_])/
        /()(?!return[^A-Za-z0-9_])/
        /()(?!rtInclude[^A-Za-z0-9_])/
        /()(?!var[^A-Za-z0-9_])/
        => {{}}
};

// the top context is a PUL fcontext
psl {
    this "__pul_fc" this memberset
};

// now plofbnf
pslbnf {
    top = white plofbnf => { push0 1 integer index }

    plofbnf = "plofbnf" /\{/ white plofbnf_productions /\}/ white /;/ white => {
        push0 3 integer index
        {[gcommit]} concat
    }

    plofbnf_productions = plofbnf_productions plofbnf_production => {
        push0 0 integer index
        push1 1 integer index concat
    }
    plofbnf_productions = plofbnf_production => {
        push0 0 integer index
    }

    plofbnf_production = pslbnf_production => { push0 0 integer index }
    plofbnf_production =
        /[A-Za-z_][A-Za-z0-9_]*/ white /=/ white
        pslbnf_targets /=>/ white
        "plof" /\{/ white plof_semicolon /\}/ white => {

        // push the name and targets
        push0 0 integer index
        push1 4 integer index concat

        // add needless members since our replacement is useless
        { {} {} {} {} {} {} {} {} {} {} 10 integer array aconcat }

        // parse the code ...
        push2 10 integer index cwrap concat

        {
            // replace markers
            push1 replace
        } concat cwrap concat

        // gadd the whole thing
        {gadd} concat

        // make it immediate
        iwrap
    }
};


// Integers
psl {
    // basic opInteger, filled in later
    pul_fcontext "opInteger" {
        new push0 "__pul_val" push3 0 integer index memberset
    } memberset
};
pslbnf {
    plof_literal = number token white => {
        push0 0 integer index
        {
            // call opInteger to wrap it up
            integer
            1 integer array
            this "opInteger" resolve member call
        } concat

        cwrap {pul_funcwrap} concat
    }
};


// The most important object in the game, Object
psl {
    new push0 pul_fcontext parentset

    // top.Object = ...
    pul_fcontext "Object" push2 memberset

    // Object.this = Object
    push0 "this" push2 memberset

    // Object.__pul_type = [Object]
    push0 "__pul_type"
        push2 1 integer array 
        push0 push4 parentset
    memberset

    // opDuplicate to duplicate objects
    pul_fcontext "opDuplicate"
    {
        push0 0 integer index

        // make the new object
        new combine

        // object.this = object
        push0 "this" push2 memberset

        // objects are function contexts
        push0 "__pul_fc" push2 memberset

        // their type is based on the parent type (if set)
        push0 "__pul_type" member null
        {
            // no parent type
            push0 "__pul_type"
                push2 1 integer array
            memberset
        }
        {
            // use the parent type
            push0 "__pul_type"
                push2 1 integer array
                push3 "__pul_type" member pul_eval
                aconcat
                push0 push4 parentset
            memberset
        } cmp

        // copy opMember (if set)
        push0 "opMember" member null
        {}
        {
            push0 "opMember"
                push2 "opMember" member pul_eval
                new combine push0 push4 parentset
            memberset
        } cmp

        // and reparent everything
        push0 push2 0 integer index 2 integer array
        this "opReparent" resolve member call pop
    } memberset

    // opReparent reparents members of $0 from $1
    pul_fcontext "opReparent"
    {
        push0 0 integer index
        push1 1 integer index
        push1 members
        0 integer
        4 integer array
        {
            // args: [object, old, members, index]

            // have we finished?
            push0 2 integer index length
            push1 3 integer index
            {
                // yes, we're done
                new
                    push0 "__pul_opreparent_done" new memberset
                throw
            }
            {
                // no, check this one
                push0 0 integer index
                    push1 2 integer index
                        push2 3 integer index
                    index
                member

                // if the parent is the old one, we'll reparent
                parent push1 1 integer index
                {
                    push0 0 integer index
                        push1 2 integer index
                            push2 3 integer index
                        index

                        // now we have the object and the name, so reparent it
                        push1 push1 member
                        1 integer array
                        this "opDuplicate" resolve member call pul_eval
                        push0 push3 parentset
                    memberset
                }
                {} cmp
            } lte

            // now step
            push0
            3 integer
                push1 3 integer index
                    1 integer
                add
            indexset
            loop
        }
        {
            // was this our throw?
            push0 "__pul_opreparent_done" member null
            {
                // nope
                throw
            } {} cmp
        } catch
    } memberset

    // opCombine is defined below as it depends on duplication
};


// Basic object definition
pslbnf {
    plof_bind => plof_combine;

    plof_assign = plof_assign_next ":=" "\[" plof_obj_defs "\]" => {
        // get the left
        push0 0 integer index
        {pul_eval} concat

        // then run the extender
        push1 3 integer index concat

        // wrap it up
        cwrap {pul_funcwrap} concat
    }

    plof_combine = plof_combine ":" "\[" plof_obj_defs "\]" => {
        // call opDuplicate
        push0 0 integer index
        {
            pul_eval
            1 integer array
            this "opDuplicate" resolve member call
            push0
        } concat

        // then run the extender
        push1 3 integer index cwrap concat
        {
            // stack: old new new extender
            push0 push2 parentset call pop
        } concat

        // wrap
        cwrap {pul_funcwrap} concat
    }
    plof_combine = plof_combine ":" plof_combine_next => {
        // combine them
        push0 0 integer index
        {pul_eval} concat
        push1 2 integer index concat
        {
            pul_eval push1 push1 combine

            // stack: old1 old2 new

            // then call opCombine
            3 integer array
            push0 this "opCombine" resolve member call
        } concat

        // wrap
        cwrap {pul_funcwrap} concat
    }
    plof_combine = plof_combine_next => {
        push0 0 integer index
    }

    plof_obj_defs = plof_obj_defs plof_obj_defs_next => {
        push0 0 integer index
        push1 1 integer index concat
    }
    plof_obj_defs = plof_obj_defs_next => {
        push0 0 integer index
    }
    plof_obj_defs = white => {
        {}
    }
    plof_obj_defs => plof_obj_def;

    plof_obj_def = plof_identifier "=" plof_bind_next ";" => {
        {push0}
        push1 0 integer index concat
        push1 2 integer index concat
        {pul_eval push0 push4 parentset memberset} concat
    }
};

psl {
    // opCombine reconciles combined objects
    pul_fcontext "opCombine"
    {
        // arg: [old1, old2, new]
        this "old1" push2 0 integer index memberset
        this "old2" push2 1 integer index memberset
        push0 2 integer index this "new" push2 memberset

        // object.this = object
        push0 "this" push2 memberset

        // objects are function contexts
        push0 "__pul_fc" push2 memberset
        pop

        // their type is based on the parent types (if set)
        this "old1" member "__pul_type" member pul_eval null
        {
            // none on the left, how 'bout the right
            this "old2" resolve member "__pul_type" member pul_eval null
            {
                // none on either side, just use itself
                this "new" resolve member "__pul_type"
                    push1 1 integer array
                memberset
            }
            {
                // right but not left
                this "new" resolve member "__pul_type"
                    push1 1 integer array
                    this "old2" resolve member "__pul_type" member pul_eval
                    aconcat
                memberset
            } cmp
        }
        {
            // left is set, how 'bout the right
            this "old2" resolve member "__pul_type" member pul_eval null
            {
                // left but not right
                this "new" resolve member "__pul_type"
                    push1 1 integer array
                    this "old1" resolve member "__pul_type" member pul_eval
                    aconcat
                memberset
            }
            {
                // both set
                this "new" resolve member "__pul_type"
                    push1 1 integer array
                    this "old2" resolve member "__pul_type" member pul_eval
                    aconcat
                    this "old1" resolve member "__pul_type" member pul_eval
                    aconcat
                memberset
            } cmp
        } cmp

        // reparent all members
        this "new" member
        this "old1" member
        2 integer array
        this "opReparent" resolve member call pop
        this "new" member
        this "old2" member
        2 integer array
        this "opReparent" resolve member call pop

        2 integer index
    } memberset
};
